---
title: C
date: 2025-09-02 21:32:11
tags: CS61C
---

# CS61C 20FALL C 内容

### C 与各种编程语言
C 作为一个接近底层，能够管理内存，操作位的语言，赋予了程序员极大的自由度，程序员可以创建非常不稳定的代码 (运行了1000次没事，但1001次时崩溃了)，同时也带来了麻烦的内存管理有了C 之后，我们实现了一个能在不同机器上运行同一个代码的能力。 

java 源自于C 吸取了C 的教训与经验，JVM的出现使系统不再是编译的障碍。

RUST 是一种C但安全的语言 既有C的强大能力， 管理底层的能力， 还更安全

Go 是在你想用机器的大量核心运行一个程序的良好选择，极致的性能并以轻量的方式处理多个线程和多个核心

### C vs Java

### 编译器与解释器

#### C工作的方式————编译：

![图(1): 编译过程的简单描述](https://github.com/shysenei/images/blob/main/CS61C/CS61C(2).png?raw=true)

![图(2): 加入CPP(C Pre-Processor)的编译过程](https://github.com/shysenei/images/blob/main/CS61C/CS61C(3).png?raw=true)



C通过其编译器(也是一个程序) 将c语言程序直接转换为机器码，编译通常分为两部分，第一部分将.c文件转换成.o文件(里面是被编译成的汇编语言)，随后将.o文件与库链接在一起形成可执行文件，当然CPP会将.c文件先变成.i文件，#其实是cpu指令集，#include是将头文件放进去(抓取.h文件并放入.i文件中)

优点:

快速，高效，对于更改的程序只需要将更改的程序单独重新编译再链接即可

缺点:

对编译的文件来说(包含可执行的)，其实它们是architecture-specific，不仅与处理器类型有关(x86, RISC-V) 还和操作系统有关(windows, macos)

#### 不同语言的运行方式

C(就是编译，省略)

java: 引入了虚拟机，先将源代码编译成字节码这一个中间形态，借助JVM进行实时编译

python: 解释型语言，逐行读取，实时运行，虽然慢但因为其中多种多样对硬件有优化的库使其在现在依然是科学计算的首选语言。


### 指针

![图(3):非常好的理解C的按值传递和解引用的小程序](https://github.com/shysenei/images/blob/main/CS61C/CS61C(4).png?raw=true)

![图(4):函数指针示例](https://github.com/shysenei/images/blob/main/CS61C/CS61C(5).png?raw=true)

声明指针： int *p 这里我们声明了一个指针p *在这里表示它是个指针

取址符： &p 在这里我们用&得到了p这个元素的地址

解引用： *p = 50 在这里我们将指针p所指的位置里的元素赋值为50， *在这里是解引用符号，p是指针，那么 *p就是指针所指位置里的元素值，一个 *能解一个，要是碰到指针嵌套就需要多个 *了

数组变量其实就是一个指向数组首个元素位置的指针

总的来说指针既高效又危险，有了指针我们能将原本全部复制再传输的文件变成只传输一个指针，大大节约了时间和空间，但其所包含的内存管理让人头大。


### 内存管理
malloc 动态分配内存，这是一个返回void指针 (指向 generic space)的函数, 占用堆空间

malloc vs array:

malloc慢， array快，但在内存不足以分配的情况下，malloc更健壮，会返回null，但array会使程序崩溃

关于 malloc :

(1) 一旦调用 malloc 分配的内存里存放的是 garbage， 在我们为其赋值前不要使用它

(2) 在动态分配空间之后，我们必须在最后动态的 free(释放)它


### C 的三个内存池(pools of memory):

![图(5):内存空间示意图](https://github.com/shysenei/images/blob/main/CS61C/CS61C(1).png?raw=true)

静态存储区 (static storage): 存储全局变量，大小永远不变

栈区 (stack): 存储局部变量，与堆区共享一部分内存，与数据结构中的栈的概念一样。栈里的内存是连续的。 栈帧存储了返回地址，参数和局部变量。由于只需要上下移动指针所以很快。由于栈非常快这种特性，在栈帧返回的时候，栈帧中的那些值不会被擦除，它们仍然存在，只是我们不能用c语言显式调用它们了

堆区 (heap): 动态存储区，malloc后的内存分配就来自堆区，与栈区共享一部分内存，与数据结构中的堆的概念不一样。每一次malloc的内存是连续的，但彼此之间不一定连续，这就导致了内存碎片化。由于需要遍历所以比栈慢